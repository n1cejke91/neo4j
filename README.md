# Графовые базы данных и сравнение с реляционными

## 1. Примеры применения графовых баз данных

### Пример 1: Социальная сеть

**Контекст:**  
В социальной сети (например, ВКонтакте) пользователи могут дружить, лайкать посты, состоять в группах.  
Это классическая графовая структура:  
- **Узлы** — пользователи, посты, группы  
- **Рёбра** — дружба, лайк, членство  

**Почему графовая БД удобна:**  
- Быстрый поиск общих друзей  
- Построение графа связей  
- Рекомендации на основе связей  

---

### Пример 2: Рекомендательная система фильмов

**Контекст:**  
Пользователи оценивают фильмы. Можно строить связи между пользователями, фильмами, жанрами и оценками.  
Если два пользователя оценивали одни и те же фильмы одинаково — они схожи.

**Почему графовая БД удобна:**  
- Поиск схожих пользователей  
- Рекомендации фильмов на основе связей  
- Гибкая структура  

---

### Пример 3: Анализ кибербезопасности

**Контекст:**  
Устройства в сети обмениваются данными. Если обнаружено заражённое устройство — нужно понять, как угроза могла распространиться.

**Почему графовая БД удобна:**  
- Поиск кратчайших путей между узлами  
- Выявление циклов (возможных угроз)  
- Построение дерева распространения  

---

## 2. Сравнение реализации в Neo4j и PostgreSQL

### Пример: Рекомендательная система фильмов

#### Реализация в Neo4j (Cypher)

```cypher
// Очистим базу
MATCH (n) DETACH DELETE n;

// Создадим данные
CREATE (:Director {name: 'Christopher Nolan'})-[:CREATED]->(:Movie {title: 'Inception'});
CREATE (:Actor {name: 'Leonardo DiCaprio'})-[:PLAYED_IN]->(:Movie {title: 'Inception'});
```

#### Реализация в PostgreSQL (SQL)

```sql
-- Таблицы
CREATE TABLE Director (
    id SERIAL PRIMARY KEY,
    name TEXT
);

CREATE TABLE Movie (
    id SERIAL PRIMARY KEY,
    title TEXT
);

CREATE TABLE Actor (
    id SERIAL PRIMARY KEY,
    name TEXT
);

CREATE TABLE Created (
    director_id INT REFERENCES Director(id),
    movie_id INT REFERENCES Movie(id)
);

CREATE TABLE PlayedIn (
    actor_id INT REFERENCES Actor(id),
    movie_id INT REFERENCES Movie(id)
);

-- Вставка данных
INSERT INTO Director (name) VALUES ('Christopher Nolan');
INSERT INTO Movie (title) VALUES ('Inception');
INSERT INTO Actor (name) VALUES ('Leonardo DiCaprio');

-- Пример вставки связей (предположим id = 1)
INSERT INTO Created VALUES (1, 1);
INSERT INTO PlayedIn VALUES (1, 1);
```

### Сравнительная таблица

```
| Операция                          | Neo4j (Cypher)                           | PostgreSQL (SQL)                               | Комментарий                 |
| --------------------------------- | ---------------------------------------- | ---------------------------------------------- | --------------------------- |
| Создание сущностей и связей       | Интуитивно, в 1 строку                   | Много запросов, вручную управлять ID           | ✅ Cypher проще             |
| Поиск режиссёра фильма            | MATCH (d:Director)-[:CREATED]->(m:Movie) | JOIN Director → Created → Movie                | ✅ Cypher читается лучше    |
| Свойства на связи                 | SET r.year = 2010                        | Нужно менять схему таблицы                     | ✅ Гибче в Neo4j            |
| Удаление сущности и связей        | DETACH DELETE                            | Удаление вручную из всех связанных таблиц      | ✅ Cypher удобнее           |
| Рекурсивный поиск по связям       | MATCH (a)-[*1..3]->(b)                   | WITH RECURSIVE выражения                       | ✅ Neo4j быстрее и короче   |
```

## 3. Выводы

**Когда лучше использовать Neo4j:**

- Сложные, многоуровневые связи
- Сценарии с рекомендациями, анализом, графами
- Удобство чтения и записи

**Когда лучше реляционная БД:**

- Простые и структурированные данные
- Высокая транзакционная надёжность
- Интеграция с BI и отчётами

